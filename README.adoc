=  Nested Hash
Benjamin b.james.neustadt@gmail.com
:author: Benjamin
:copyright: (C) 2022 {author}
:doctype: book
:experimental:
:header_footer: true
:icons: font
:sectnums:
:sourcedir: assets
:toc: left
:source-highlighter: highlight.js
:highlightjsdir: ./highlight
//URLs

== Brief

Using a ruby script only, turn the data in the last worksheet of the attached workbook in to a nested
Hash where:

-  the outermost keys are the values for *column D* (Device_Type.name)
-  the next outermost are the corresponding values for *column E* (Device_Model.manufacturer_identifier)
-  the next outermost are the corresponding values for *column I* (Device_Model.model_identifier_concatenated_with_hardware_version)

The corresponding values at the innermost level are each a hash composed as:

[source, txt]
----

{

  firmware_version: the value in *column J* (Device_Model.firmware_version),
  smets_chts_version: the value in *column K* (SMETS_CHTS Version.Version_number_and_effective_date),
  gbcs_version:Â  the value in *column L* (GBCS Version.version_number),
  image_hash: the value in *column M* (Manufacturer_Image.hash)

}
----

The data from all rows in the worksheet must be included in the Hash,
except those marked "Removed" in *column C*, which must be excluded.
Add comments to explain your solution and why you believe it is optimal


== Usage

The script is currently only fit to be used by Octopus team, but the logic of checking whether a key is already existant can be adopted on other projects.
To use the script with the example file (the only file currently working for it)

Steps:

- git clone this repo:

[source, ruby]
----
git clone [repo]
----

- Install dependencies:

----
bundle install
----

- Run the specs:

----
rspec -fd
----

- Run the script:

----
bin/csv-to-hash
----

* The file is currently informed inside the executable file in bin/

== Testing

The testing suite used is Rspec.
The process followed was BDD.
Simplcov is used to check for code coverage.

== Approach

The different classes are currently all inside one file to facilitate reading.

=== Notes

.My preliminary understanding was that it shuold look something like this
.Should look something like this:
[source, rb]
----
  {
    "Column D value"=>{
      "Column E value"=>{
        "Column I value"=>{
          :firmware_version=>    "Column J value",
          :smets_chts_version=>  "Column K value",
          :gbcs_version=>        "Column L value",
          :image_hash=>          "Column M value"
        }
      }
    }
  }
----

I was uncertain whether it was "valid" to use an array to store the inner hashes. Since the brief only made mention of a nested array.
For the inner hashes, I therefore took an approach that checked whether the key was already in use, and if so turned the value on the firmware key into the key of the remaining key/value pairs of the inner hash.
This way we would not lose any of the data, and we would still habe the speed of the hash table.

However, I then realised that as we got to the last value on the inner hash, we would either have to create a key for it using an index number (but we get that for free with arrays),
or make it a value inside an array anyway. (I have left some examples of what I mean at the end of the file).

I felt the optimal thing to do was to place it inside an array early on, as we still dont lose any data. 
We can still leverage the speed of hash look up, only up to a certain point.

The benefit of this is that if at some stage we get to the last inner value, we will have to store the image_hash in an array, and it will now be truncated from it's original "shape"
so it is easier to retain the shape of the inner hash now, and if we need to perform a comparison on any of the inner hash we can so iteratively using the array.

I therefore chose to focus on this line: 
"The corresponding values at the innermost level are each a hash composed as""
I decided to take a second approach instead.
The innermost hash should never be changed and always retain the key value relationship already in place.

If Column I value is already in use, then that key will become the key for an array containing the different instances of the inner hash.

.Like this
[source, rb]
----

expected = {
  'Type_Communications' => {            
    'Mfg_1' => {                        
      '1.1.0' =>  [
        {# If this is already in use                     
          firmware_version: '1.1.1',      
          smets_chts_version: 'CHTS V1',  
          gbcs_version: 'GBCS Version 1', 
          image_hash: 'image1hash'        
        },
        {  # And this one will be identical
          :firmware_version => "1a.1.1",
          :gbcs_version => "GBCS Version 1a",
          :smets_chts_version => "CHTS V1a",
          :image_hash => "image1Ahash"
        }
      ]
    }
  }
}
----

.Example of what we can do if we make the value the key for first inner-most hash
[source, rb]
----
    expected = {
     'Type_Communications' => {
       'Mfg_1' => {
         '1.1.0' => {
           '1a.1.1' => {
             "GBCS Version 1" => {
               :smets_chts_version => 'CHTS V1',
               :image_hash => 'image1hash'
             },
             "GBCS Version 1a" => {
               :smets_chts_version => "CHTS V1a",
               :image_hash => "image1Ahash"
             },
             "GBCS Version 1b" => {
               :smets_chts_version => 'CHTS V1b',
               :image_hash => 'image1Ahash'
             },
             "GBCS Version 1c" => {
              :smets_chts_version => 'CHTS V1b',
              :image_hash => 'image1Ahash'
            }
           }
         }
       }
     }
   }
----

I noticed the array this when I got to this test:


[source, rb]
----

  it 'It groups with duplicate headers/keys for "fifth inner-key" - 2 values' do

    input_csv =
    <<~CSV
      Version,Entry.number,Entry.status,Device_Type.name,Device_Model.manufacturer_identifier,Device_Model.model_identifier,Device_Model.hardware_version.version,Device_Model.hardware_version.revision,Device_Model.model_identifier_concatenated_with_hardware_version,Device_Model.firmware_version,SMETS_CHTS Version.Version_number_and_effective_date,GBCS Version.version_number,Manufacturer_Image.hash
      Version 1,1,Current,Type_Communications,Mfg_1,Model_1,1.0.0,AC,1.1.0,1a.1.1,CHTS V1,GBCS Version 1,image1hash
      Version 1,1,Current,Type_Communications,Mfg_1,Model_1,1.0.0,AC,1.1.0,1a.1.1,CHTS V1a,GBCS Version 1,image1Ahash
    CSV

    expected = {
     'Type_Communications' => {
       'Mfg_1' => {
         '1.1.0' => {
           '1a.1.1' => {
             "GBCS Version 1" => {
              "CHTS V1" => {
               :image_hash => 'image1hash'
              },
             {
              "CHTS V1a" => {
               :image_hash => "image1Ahash"
              }
            }
          }
         }
       }
     }
     }
    }
 
    actual = data_parse(input_csv)
    expect(actual).to eq expected
  end

# If the 'gbcs' version is already in use for an incoming hash, then we will have to store the image in some kind of array,
----

.Thoughts on the end:
[source, ruby]
----
# The question is what is better to store the last value. we know that if this happens, it will only happen once, so speed at this stage is maybe not an issue.
# though they have specified a nest hash. so, that can mean, 
# Thoughts on ending:

## OPTION 1

    expected = {
     'Type_Communications' => {
       'Mfg_1' => {
         '1.1.0' => {
           '1a.1.1' => {
             "GBCS Version 1" => {
              'CHTS V1' =>[{
               :image_hash => 'image1hash'
              },
              {
               :image_hash => "image2Ahash"
             }]
              }
             }
           }
         }
       }
     }
   }

## OPTION 2
# An index does this for free though
    expected = {
     'Type_Communications' => {
       'Mfg_1' => {
         '1.1.0' => {
           '1a.1.1' => {
             "GBCS Version 1" => {
              'CHTS V1' => {
                0 => 'image1hash',
                1 => "image2Ahash"
              }
              }
             }
           }
         }
       }
     }
   }

## OPTION 3

    expected = {
     'Type_Communications' => {
       'Mfg_1' => {
         '1.1.0' => {
           '1a.1.1' => {
             "GBCS Version 1" => {
              'CHTS V1' =>[
              'image1hash',
              "image2Ahash"
             ]
              }
             }
           }
         }
       }
     }
   }
----
